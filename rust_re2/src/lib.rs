//! rust_re2 - RE2-style regex search for μEmacs
//!
//! API Version: 4 (ABI-Stable Named Lookup)
//!
//! Uses get_function() for ABI stability - immune to API struct layout changes.
//!
//! Commands provided:
//! - re2: Search for pattern in current directory
//! - re2-word: Search for word under cursor
//! - re2-case: Toggle case insensitive mode
//! - re2-smart: Toggle smart case mode
//! - re2-word-boundary: Toggle whole word matching
//! - re2-hidden: Toggle hidden files
//! - re2-gitignore: Toggle .gitignore respect
//!
//! Press Enter in results buffer to jump to file:line.

mod ffi;
mod search;

use ffi::{CmdFn, EventFn, GetFunctionFn, UemacsApi, UemacsEvent, UemacsExtension};
use search::SearchOptions;
use std::ffi::{c_char, c_int, c_void, CStr, CString};
use std::sync::atomic::{AtomicPtr, Ordering};
use std::sync::Mutex;

/// Results buffer name
const RE2_RESULTS_BUFFER: &str = "*re2-results*";

/// Event name for key input
static INPUT_KEY_EVENT: &[u8; 10] = b"input:key\0";

/// Extension name for config lookups
static EXT_NAME: &[u8; 9] = b"rust_re2\0";

/// Global get_function pointer - set during init
static GET_FUNCTION: AtomicPtr<()> = AtomicPtr::new(std::ptr::null_mut());

/// Last search pattern (for repeat searches)
static LAST_PATTERN: Mutex<Option<String>> = Mutex::new(None);

/// Current search options (loaded from config, can be toggled at runtime)
static SEARCH_OPTIONS: Mutex<Option<SearchOptions>> = Mutex::new(None);

// Include build-time API version generated by build.rs
include!(concat!(env!("OUT_DIR"), "/api_version.rs"));

// Static strings with explicit lifetime for C FFI
static NAME: &[u8; 9] = b"rust_re2\0";
static VERSION: &[u8; 6] = b"4.0.0\0";
static DESC: &[u8; 51] = b"RE2-style regex search (Thompson NFA, linear-time)\0";

/// Extension descriptor - static lifetime, C-compatible strings
static EXTENSION: UemacsExtension = UemacsExtension {
    api_version: UEMACS_API_VERSION,  // From build.rs via env var
    name: NAME.as_ptr() as *const c_char,
    version: VERSION.as_ptr() as *const c_char,
    description: DESC.as_ptr() as *const c_char,
    init: Some(re2_init),
    cleanup: Some(re2_cleanup),
};

// ============================================================================
// Function pointer types for the API functions we use
// ============================================================================

type OnFn = unsafe extern "C" fn(*const c_char, EventFn, *mut c_void, c_int) -> c_int;
type OffFn = unsafe extern "C" fn(*const c_char, EventFn) -> c_int;
type ConfigIntFn = unsafe extern "C" fn(*const c_char, *const c_char, c_int) -> c_int;
type ConfigBoolFn = unsafe extern "C" fn(*const c_char, *const c_char, bool) -> bool;
type ConfigStringFn = unsafe extern "C" fn(*const c_char, *const c_char, *const c_char) -> *const c_char;
type RegisterCommandFn = unsafe extern "C" fn(*const c_char, CmdFn) -> c_int;
type UnregisterCommandFn = unsafe extern "C" fn(*const c_char) -> c_int;
type CurrentBufferFn = unsafe extern "C" fn() -> *mut c_void;
type BufferFilenameFn = unsafe extern "C" fn(*mut c_void) -> *const c_char;
type BufferNameFn = unsafe extern "C" fn(*mut c_void) -> *const c_char;
type BufferInsertFn = unsafe extern "C" fn(*const c_char, usize) -> c_int;
type BufferCreateFn = unsafe extern "C" fn(*const c_char) -> *mut c_void;
type BufferSwitchFn = unsafe extern "C" fn(*mut c_void) -> c_int;
type BufferClearFn = unsafe extern "C" fn(*mut c_void) -> c_int;
type SetPointFn = unsafe extern "C" fn(c_int, c_int);
type GetWordAtPointFn = unsafe extern "C" fn() -> *mut c_char;
type GetCurrentLineFn = unsafe extern "C" fn() -> *mut c_char;
type MessageFn = unsafe extern "C" fn(*const c_char);
type PromptFn = unsafe extern "C" fn(*const c_char, *mut c_char, usize) -> c_int;
type UpdateDisplayFn = unsafe extern "C" fn();
type FindFileLineFn = unsafe extern "C" fn(*const c_char, c_int) -> c_int;
type FreeFn = unsafe extern "C" fn(*mut c_void);
type LogInfoFn = unsafe extern "C" fn(*const c_char);

// ============================================================================
// Stored function pointers (looked up via get_function during init)
// ============================================================================

struct Api {
    on: Option<OnFn>,
    off: Option<OffFn>,
    config_int: Option<ConfigIntFn>,
    config_bool: Option<ConfigBoolFn>,
    config_string: Option<ConfigStringFn>,
    register_command: Option<RegisterCommandFn>,
    unregister_command: Option<UnregisterCommandFn>,
    current_buffer: Option<CurrentBufferFn>,
    buffer_filename: Option<BufferFilenameFn>,
    buffer_name: Option<BufferNameFn>,
    buffer_insert: Option<BufferInsertFn>,
    buffer_create: Option<BufferCreateFn>,
    buffer_switch: Option<BufferSwitchFn>,
    buffer_clear: Option<BufferClearFn>,
    set_point: Option<SetPointFn>,
    get_word_at_point: Option<GetWordAtPointFn>,
    get_current_line: Option<GetCurrentLineFn>,
    message: Option<MessageFn>,
    prompt: Option<PromptFn>,
    update_display: Option<UpdateDisplayFn>,
    find_file_line: Option<FindFileLineFn>,
    free: Option<FreeFn>,
    log_info: Option<LogInfoFn>,
}

static API: Mutex<Option<Api>> = Mutex::new(None);

/// Entry point - called by μEmacs dlopen() loader
#[no_mangle]
pub extern "C" fn uemacs_extension_entry() -> *mut UemacsExtension {
    &EXTENSION as *const _ as *mut _
}

/// Look up a function by name using get_function
unsafe fn lookup(name: &[u8]) -> Option<unsafe extern "C" fn()> {
    let get_fn = GET_FUNCTION.load(Ordering::SeqCst);
    if get_fn.is_null() {
        return None;
    }
    let get_fn: GetFunctionFn = std::mem::transmute(get_fn);
    get_fn(name.as_ptr() as *const c_char)
}

/// Initialize the extension
extern "C" fn re2_init(api_ptr: *mut UemacsApi) -> c_int {
    // Get get_function from the API struct
    let get_fn = unsafe {
        if api_ptr.is_null() {
            eprintln!("rust_re2: NULL API pointer");
            return -1;
        }
        match (*api_ptr).get_function {
            Some(f) => f,
            None => {
                eprintln!("rust_re2: Requires μEmacs with get_function() support");
                return -1;
            }
        }
    };

    // Store get_function for later lookups
    GET_FUNCTION.store(get_fn as *mut (), Ordering::SeqCst);

    // Look up all API functions by name
    unsafe {
        let api = Api {
            on: lookup(b"on\0").map(|f| std::mem::transmute(f)),
            off: lookup(b"off\0").map(|f| std::mem::transmute(f)),
            config_int: lookup(b"config_int\0").map(|f| std::mem::transmute(f)),
            config_bool: lookup(b"config_bool\0").map(|f| std::mem::transmute(f)),
            config_string: lookup(b"config_string\0").map(|f| std::mem::transmute(f)),
            register_command: lookup(b"register_command\0").map(|f| std::mem::transmute(f)),
            unregister_command: lookup(b"unregister_command\0").map(|f| std::mem::transmute(f)),
            current_buffer: lookup(b"current_buffer\0").map(|f| std::mem::transmute(f)),
            buffer_filename: lookup(b"buffer_filename\0").map(|f| std::mem::transmute(f)),
            buffer_name: lookup(b"buffer_name\0").map(|f| std::mem::transmute(f)),
            buffer_insert: lookup(b"buffer_insert\0").map(|f| std::mem::transmute(f)),
            buffer_create: lookup(b"buffer_create\0").map(|f| std::mem::transmute(f)),
            buffer_switch: lookup(b"buffer_switch\0").map(|f| std::mem::transmute(f)),
            buffer_clear: lookup(b"buffer_clear\0").map(|f| std::mem::transmute(f)),
            set_point: lookup(b"set_point\0").map(|f| std::mem::transmute(f)),
            get_word_at_point: lookup(b"get_word_at_point\0").map(|f| std::mem::transmute(f)),
            get_current_line: lookup(b"get_current_line\0").map(|f| std::mem::transmute(f)),
            message: lookup(b"message\0").map(|f| std::mem::transmute(f)),
            prompt: lookup(b"prompt\0").map(|f| std::mem::transmute(f)),
            update_display: lookup(b"update_display\0").map(|f| std::mem::transmute(f)),
            find_file_line: lookup(b"find_file_line\0").map(|f| std::mem::transmute(f)),
            free: lookup(b"free\0").map(|f| std::mem::transmute(f)),
            log_info: lookup(b"log_info\0").map(|f| std::mem::transmute(f)),
        };

        // Verify critical functions
        if api.register_command.is_none() {
            eprintln!("rust_re2: Failed to look up register_command");
            return -1;
        }

        // Store API
        *API.lock().unwrap() = Some(api);
    }

    // Load config into search options
    {
        let mut guard = SEARCH_OPTIONS.lock().unwrap();
        *guard = Some(load_config());
    }

    // Register commands
    with_api(|api| unsafe {
        if let Some(register) = api.register_command {
            let cmd_search = CString::new("re2").unwrap();
            let cmd_word = CString::new("re2-word").unwrap();
            let cmd_case = CString::new("re2-case").unwrap();
            let cmd_smart = CString::new("re2-smart").unwrap();
            let cmd_word_boundary = CString::new("re2-word-boundary").unwrap();
            let cmd_hidden = CString::new("re2-hidden").unwrap();
            let cmd_gitignore = CString::new("re2-gitignore").unwrap();

            register(cmd_search.as_ptr(), cmd_re2_search);
            register(cmd_word.as_ptr(), cmd_re2_search_word);
            register(cmd_case.as_ptr(), cmd_re2_toggle_case);
            register(cmd_smart.as_ptr(), cmd_re2_toggle_smart);
            register(cmd_word_boundary.as_ptr(), cmd_re2_toggle_word_boundary);
            register(cmd_hidden.as_ptr(), cmd_re2_toggle_hidden);
            register(cmd_gitignore.as_ptr(), cmd_re2_toggle_gitignore);
        }

        // Register key event handler
        if let Some(on) = api.on {
            on(
                INPUT_KEY_EVENT.as_ptr() as *const c_char,
                re2_key_event_handler,
                std::ptr::null_mut(),
                0,
            );
        }

        // Log that we loaded
        if let Some(log_info) = api.log_info {
            let msg = CString::new("rust_re2: Loaded (v4.0, ABI-stable)").unwrap();
            log_info(msg.as_ptr());
        }
    });

    0 // Success
}

/// Cleanup the extension
extern "C" fn re2_cleanup() {
    with_api(|api| unsafe {
        // Unregister key event handler
        if let Some(off) = api.off {
            off(
                INPUT_KEY_EVENT.as_ptr() as *const c_char,
                re2_key_event_handler,
            );
        }

        if let Some(unregister) = api.unregister_command {
            let cmd_search = CString::new("re2").unwrap();
            let cmd_word = CString::new("re2-word").unwrap();
            let cmd_case = CString::new("re2-case").unwrap();
            let cmd_smart = CString::new("re2-smart").unwrap();
            let cmd_word_boundary = CString::new("re2-word-boundary").unwrap();
            let cmd_hidden = CString::new("re2-hidden").unwrap();
            let cmd_gitignore = CString::new("re2-gitignore").unwrap();

            unregister(cmd_search.as_ptr());
            unregister(cmd_word.as_ptr());
            unregister(cmd_case.as_ptr());
            unregister(cmd_smart.as_ptr());
            unregister(cmd_word_boundary.as_ptr());
            unregister(cmd_hidden.as_ptr());
            unregister(cmd_gitignore.as_ptr());
        }
    });
}

/// Execute a closure with the API, if available
fn with_api<F, R>(f: F) -> Option<R>
where
    F: FnOnce(&Api) -> R,
{
    let guard = API.lock().ok()?;
    let api = guard.as_ref()?;
    Some(f(api))
}

/// Read a boolean config value
fn config_bool(key: &str, default: bool) -> bool {
    with_api(|api| unsafe {
        if let Some(config_fn) = api.config_bool {
            if let Ok(ckey) = CString::new(key) {
                return config_fn(
                    EXT_NAME.as_ptr() as *const c_char,
                    ckey.as_ptr(),
                    default,
                );
            }
        }
        default
    })
    .unwrap_or(default)
}

/// Read an integer config value
fn config_int(key: &str, default: i32) -> i32 {
    with_api(|api| unsafe {
        if let Some(config_fn) = api.config_int {
            if let Ok(ckey) = CString::new(key) {
                return config_fn(
                    EXT_NAME.as_ptr() as *const c_char,
                    ckey.as_ptr(),
                    default,
                );
            }
        }
        default
    })
    .unwrap_or(default)
}

/// Read a string config value
fn config_string(key: &str, default: &str) -> String {
    with_api(|api| unsafe {
        if let Some(config_fn) = api.config_string {
            if let (Ok(ckey), Ok(cdefault)) = (CString::new(key), CString::new(default)) {
                let ptr = config_fn(
                    EXT_NAME.as_ptr() as *const c_char,
                    ckey.as_ptr(),
                    cdefault.as_ptr(),
                );
                if !ptr.is_null() {
                    return CStr::from_ptr(ptr).to_string_lossy().to_string();
                }
            }
        }
        default.to_string()
    })
    .unwrap_or_else(|| default.to_string())
}

/// Parse comma-separated string into Vec<String>
fn parse_csv(s: &str) -> Vec<String> {
    if s.is_empty() {
        Vec::new()
    } else {
        s.split(',')
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect()
    }
}

/// Load search options from config
fn load_config() -> SearchOptions {
    SearchOptions {
        case_insensitive: config_bool("case_insensitive", false),
        smart_case: config_bool("smart_case", true),
        word_boundary: config_bool("word_boundary", false),
        context_before: config_int("context_before", 0) as usize,
        context_after: config_int("context_after", 0) as usize,
        invert_match: false,
        hidden: config_bool("hidden", false),
        follow_symlinks: config_bool("follow_symlinks", false),
        git_ignore: config_bool("git_ignore", true),
        max_depth: {
            let d = config_int("max_depth", 0);
            if d > 0 { Some(d as usize) } else { None }
        },
        threads: config_int("threads", 0) as usize,
        file_types: parse_csv(&config_string("file_types", "")),
        glob_include: parse_csv(&config_string("glob_include", "")),
        glob_exclude: parse_csv(&config_string("glob_exclude", "")),
        max_filesize: {
            let s = config_int("max_filesize", 0);
            if s > 0 { Some(s as u64) } else { None }
        },
        mmap: config_bool("mmap", true),
        fixed_strings: config_bool("fixed_strings", false),
        multiline: config_bool("multiline", false),
        max_count: {
            let c = config_int("max_count", 0);
            if c > 0 { Some(c as u64) } else { None }
        },
    }
}

/// Get current search options (thread-safe)
fn get_search_options() -> SearchOptions {
    let guard = SEARCH_OPTIONS.lock().unwrap();
    guard.clone().unwrap_or_default()
}

/// Update search options (thread-safe)
fn update_search_options<F: FnOnce(&mut SearchOptions)>(f: F) {
    let mut guard = SEARCH_OPTIONS.lock().unwrap();
    if let Some(ref mut opts) = *guard {
        f(opts);
    }
}

/// Show a message to the user
fn message(msg: &str) {
    with_api(|api| unsafe {
        if let Some(message_fn) = api.message {
            if let Ok(cmsg) = CString::new(msg) {
                message_fn(cmsg.as_ptr());
            }
        }
    });
}

/// Prompt user for input
fn prompt(prompt_text: &str) -> Option<String> {
    with_api(|api| unsafe {
        let prompt_fn = api.prompt?;
        let cprompt = CString::new(prompt_text).ok()?;
        let mut buf = [0u8; 256];

        if prompt_fn(cprompt.as_ptr(), buf.as_mut_ptr() as *mut c_char, buf.len()) == 0 {
            let cstr = CStr::from_ptr(buf.as_ptr() as *const c_char);
            Some(cstr.to_string_lossy().to_string())
        } else {
            None
        }
    })?
}

/// Get word at cursor
fn get_word_at_point() -> Option<String> {
    with_api(|api| unsafe {
        let get_word_fn = api.get_word_at_point?;
        let ptr = get_word_fn();
        if ptr.is_null() {
            return None;
        }
        let cstr = CStr::from_ptr(ptr);
        let result = cstr.to_string_lossy().to_string();

        if let Some(free_fn) = api.free {
            free_fn(ptr as *mut _);
        }

        Some(result)
    })?
}

/// Get current line text
fn get_current_line() -> Option<String> {
    with_api(|api| unsafe {
        let get_line_fn = api.get_current_line?;
        let ptr = get_line_fn();
        if ptr.is_null() {
            return None;
        }
        let cstr = CStr::from_ptr(ptr);
        let result = cstr.to_string_lossy().to_string();

        if let Some(free_fn) = api.free {
            free_fn(ptr as *mut _);
        }

        Some(result)
    })?
}

/// Create or get a buffer by name
fn get_or_create_buffer(name: &str) -> Option<*mut c_void> {
    with_api(|api| unsafe {
        let create_fn = api.buffer_create?;
        let cname = CString::new(name).ok()?;
        let bp = create_fn(cname.as_ptr());
        if bp.is_null() {
            None
        } else {
            Some(bp)
        }
    })?
}

/// Switch to a buffer
fn switch_to_buffer(bp: *mut c_void) -> bool {
    with_api(|api| unsafe {
        if let Some(switch_fn) = api.buffer_switch {
            return switch_fn(bp) != 0;
        }
        false
    })
    .unwrap_or(false)
}

/// Clear a buffer
fn clear_buffer(bp: *mut c_void) -> bool {
    with_api(|api| unsafe {
        if let Some(clear_fn) = api.buffer_clear {
            return clear_fn(bp) != 0;
        }
        false
    })
    .unwrap_or(false)
}

/// Insert text into current buffer
fn buffer_insert(text: &str) -> bool {
    with_api(|api| unsafe {
        if let Some(insert_fn) = api.buffer_insert {
            if let Ok(ctext) = CString::new(text) {
                return insert_fn(ctext.as_ptr(), text.len()) != 0;
            }
        }
        false
    })
    .unwrap_or(false)
}

/// Open a file at a specific line
fn find_file_line(path: &str, line: i32) -> bool {
    with_api(|api| unsafe {
        if let Some(find_fn) = api.find_file_line {
            if let Ok(cpath) = CString::new(path) {
                return find_fn(cpath.as_ptr(), line) == 0;
            }
        }
        false
    })
    .unwrap_or(false)
}

/// Update the display
fn update_display() {
    with_api(|api| unsafe {
        if let Some(update_fn) = api.update_display {
            update_fn();
        }
    });
}

/// Move cursor to a specific line (1-indexed)
fn goto_line(line: i32) {
    with_api(|api| unsafe {
        if let Some(set_point_fn) = api.set_point {
            set_point_fn(line, 0);
        }
    });
}

/// Get the directory of the current buffer's file
fn get_buffer_directory() -> Option<String> {
    with_api(|api| unsafe {
        let current_buf_fn = api.current_buffer?;
        let current_buf = current_buf_fn();
        if current_buf.is_null() {
            return None;
        }
        let filename_fn = api.buffer_filename?;
        let filename_ptr = filename_fn(current_buf);
        if filename_ptr.is_null() {
            return None;
        }
        let filename = CStr::from_ptr(filename_ptr).to_string_lossy().to_string();
        if filename.is_empty() {
            return None;
        }
        if let Some(pos) = filename.rfind('/') {
            Some(filename[..pos].to_string())
        } else {
            None
        }
    })?
}

/// Get the current buffer's name
fn get_buffer_name() -> Option<String> {
    with_api(|api| unsafe {
        let current_buf_fn = api.current_buffer?;
        let current_buf = current_buf_fn();
        if current_buf.is_null() {
            return None;
        }
        let name_fn = api.buffer_name?;
        let name_ptr = name_fn(current_buf);
        if name_ptr.is_null() {
            return None;
        }
        Some(CStr::from_ptr(name_ptr).to_string_lossy().to_string())
    })?
}

/// Check if we're in the results buffer
fn in_results_buffer() -> bool {
    get_buffer_name()
        .map(|name| name == RE2_RESULTS_BUFFER)
        .unwrap_or(false)
}

/// Perform the search and display results
fn do_search(pattern: &str) -> bool {
    {
        let mut guard = LAST_PATTERN.lock().unwrap();
        *guard = Some(pattern.to_string());
    }

    let search_dir = get_buffer_directory().unwrap_or_else(|| ".".to_string());

    message(&format!("Searching for: {} in {}...", pattern, search_dir));
    update_display();

    let opts = get_search_options();
    let result = match search::search_parallel(pattern, &search_dir, &opts) {
        Ok(r) => r,
        Err(e) => {
            message(&format!("Search error: {}", e));
            return false;
        }
    };

    if result.matches.is_empty() {
        message(&format!(
            "No matches ({} files searched in {}ms)",
            result.stats.files_searched, result.stats.elapsed_ms
        ));
        return true;
    }

    let bp = match get_or_create_buffer(RE2_RESULTS_BUFFER) {
        Some(b) => b,
        None => {
            message("Failed to create results buffer");
            return false;
        }
    };

    switch_to_buffer(bp);
    clear_buffer(bp);

    let output = search::format_results_with_stats(&result);
    buffer_insert(&output);

    goto_line(3);

    message(&format!(
        "{} matches in {} files ({}ms) - Enter to jump",
        result.stats.matches, result.stats.files_matched, result.stats.elapsed_ms
    ));
    true
}

/// Command: re2
extern "C" fn cmd_re2_search(_f: c_int, _n: c_int) -> c_int {
    let pattern = match prompt("RE2 pattern: ") {
        Some(p) if !p.is_empty() => p,
        _ => {
            message("Cancelled");
            return 0;
        }
    };

    if do_search(&pattern) { 1 } else { 0 }
}

/// Command: re2-word
extern "C" fn cmd_re2_search_word(_f: c_int, _n: c_int) -> c_int {
    let word = match get_word_at_point() {
        Some(w) if !w.is_empty() => w,
        _ => {
            message("No word at point");
            return 0;
        }
    };

    if do_search(&word) { 1 } else { 0 }
}

/// Command: re2-case
extern "C" fn cmd_re2_toggle_case(_f: c_int, _n: c_int) -> c_int {
    let mut new_val = false;
    update_search_options(|opts| {
        opts.case_insensitive = !opts.case_insensitive;
        new_val = opts.case_insensitive;
    });
    message(&format!(
        "Case insensitive: {}",
        if new_val { "ON" } else { "OFF" }
    ));
    1
}

/// Command: re2-smart
extern "C" fn cmd_re2_toggle_smart(_f: c_int, _n: c_int) -> c_int {
    let mut new_val = false;
    update_search_options(|opts| {
        opts.smart_case = !opts.smart_case;
        new_val = opts.smart_case;
    });
    message(&format!(
        "Smart case: {}",
        if new_val { "ON" } else { "OFF" }
    ));
    1
}

/// Command: re2-word-boundary
extern "C" fn cmd_re2_toggle_word_boundary(_f: c_int, _n: c_int) -> c_int {
    let mut new_val = false;
    update_search_options(|opts| {
        opts.word_boundary = !opts.word_boundary;
        new_val = opts.word_boundary;
    });
    message(&format!(
        "Word boundary: {}",
        if new_val { "ON" } else { "OFF" }
    ));
    1
}

/// Command: re2-hidden
extern "C" fn cmd_re2_toggle_hidden(_f: c_int, _n: c_int) -> c_int {
    let mut new_val = false;
    update_search_options(|opts| {
        opts.hidden = !opts.hidden;
        new_val = opts.hidden;
    });
    message(&format!(
        "Hidden files: {}",
        if new_val { "INCLUDED" } else { "EXCLUDED" }
    ));
    1
}

/// Command: re2-gitignore
extern "C" fn cmd_re2_toggle_gitignore(_f: c_int, _n: c_int) -> c_int {
    let mut new_val = false;
    update_search_options(|opts| {
        opts.git_ignore = !opts.git_ignore;
        new_val = opts.git_ignore;
    });
    message(&format!(
        ".gitignore: {}",
        if new_val { "RESPECTED" } else { "IGNORED" }
    ));
    1
}

/// Core goto logic - jump to file:line from current line
fn do_goto() -> bool {
    let line = match get_current_line() {
        Some(l) => l,
        None => {
            message("No line content");
            return false;
        }
    };

    if line.contains(" ACROSS ") || line.contains("errors encountered") || line.is_empty() {
        message("Not on a result line");
        return false;
    }

    let parts: Vec<&str> = line.splitn(4, ':').collect();
    if parts.len() < 2 {
        message("Not a valid result line");
        return false;
    }

    let file = parts[0];
    let line_num: i32 = match parts[1].parse() {
        Ok(n) => n,
        Err(_) => {
            message("Invalid line number");
            return false;
        }
    };

    if find_file_line(file, line_num) {
        message(&format!("{}:{}", file, line_num));
        true
    } else {
        message(&format!("Failed to open: {}", file));
        false
    }
}

/// Event handler for key input
extern "C" fn re2_key_event_handler(event: *mut UemacsEvent, _user_data: *mut c_void) -> bool {
    if event.is_null() {
        return false;
    }

    unsafe {
        let key_ptr = (*event).data as *const c_int;
        if key_ptr.is_null() {
            return false;
        }
        let key = *key_ptr;

        if key != '\r' as c_int && key != '\n' as c_int {
            return false;
        }

        if !in_results_buffer() {
            return false;
        }

        do_goto();
        true
    }
}
